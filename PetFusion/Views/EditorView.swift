//
//  EditorView.swift
//  PetFusion
//
//  Created by fdsa on 1/27/24.
//

import Foundation
import SwiftUI
import PencilKit
import VisionKit

extension UIApplication {
    func dismissKeyboard() {
        sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)
    }
}

class EditorViewModel: ObservableObject {

    static let shared = EditorViewModel()
    
    // General State

    // The image selected by the user to edit. Defaults to a blank white 1024x1024 image
    @Published var selectedImage: EditedImage = EditedImage()
    // The generative image generated by the user, only set once the API returns
    @Published var generatedImage: GenerativeImage?
    // Indicates whether the image picker should be displayed, used by the user to select an initial image
    @Published var presentImagePicker = false
    // Indicates whether we are waiting on an API response, used to display the loading animation
    @Published var isGeneratingImage = false
    // Switching between auto or manual mask painting
    @Published var isAutoDetectionMode = false
    // For auto detected results
    @Published var maskImage: UIImage?
    // To make the wand red, indicating failure
    @Published var autodetectDidFail = false
    
    // Used to monitor for presence of the keyboard
    @StateObject var keyboardResponder = KeyboardResponder()
    
    // Used to enforce image generation rate limits
    @ObservedObject var rateLimiter = RateLimiter.shared
    
    // Editor
    
    // user-inputted prompt for the image
    @Published var imagePrompt: String = ""
    // number of times user entered an invalid prompt
    @Published var attempts: Int = 0
    // stroke size of the tool used to draw the mask - controlled via Slider in the UI
    @Published var strokeSize = 5.0
    // main PencilKit canvas view used to draw the mask
    var canvasView: PKCanvasView = PKCanvasView()
    // main editor view, displaying the image and tools for drawing a mask and adding a prompt
    
    // Loading
    
    // indicates whether we should show an error alert
    @Published var showAlert: Bool = false
    @Published var error: LocalizedError?
    // indicates whether we should show the debug modal view
    @Published var showDebugView: Bool = false
    
    func reset() {
        self.selectedImage = EditedImage()
        self.generatedImage = nil
        self.presentImagePicker = false
        self.isGeneratingImage = false
        self.isAutoDetectionMode = false
        self.maskImage = nil
        self.autodetectDidFail = false
        self.imagePrompt = ""
        self.attempts = 0
        self.strokeSize = 5.0
        self.canvasView = PKCanvasView()
        self.showAlert = false
        self.error = nil
        self.showDebugView = false
    }
}

struct EditorView: View {
    @StateObject var editorViewModel: EditorViewModel

    // Used to dismiss EditorView programatically
    @Environment(\.presentationMode) var presentationMode

    // The main view representing the Editor View. Contains subviews for the actual editing, loading, and results
    var body: some View {
        VStack {
            Spacer()
            HStack {
                Spacer()
                Image(systemName: "chevron.down")
                    .font(.headline)
                    .foregroundColor(.secondary)
                    .padding(.top)
                Spacer()
            }
            HStack {
                Text("Editor")
                    .font(.title)
                    .fontWeight(.bold)
                    .padding([.leading, .trailing])
                Spacer()
            }
            
            if (self.editorViewModel.generatedImage == nil && self.editorViewModel.isGeneratingImage) {
                self.loadingView
            } else if (self.editorViewModel.generatedImage != nil) {
                ResultView(image: self.editorViewModel.generatedImage!)
            } else {
                self.editorView
            }
        }
        .sheet(isPresented: $editorViewModel.presentImagePicker, content: {
            ImagePicker(sourceType: .photoLibrary, editedImage: $editorViewModel.selectedImage)
        })
        .onAppear(perform: {
            // once the user visits the editor view, automatically show the image picker to select an image
            if (!self.editorViewModel.selectedImage.hasSelectedImage()) {
                self.editorViewModel.presentImagePicker = true // 0x2813e6580
            }
        })
        .onTapGesture {
            UIApplication.shared.dismissKeyboard()
        }
        .onDisappear {
            if (!self.editorViewModel.isGeneratingImage) {
                self.editorViewModel.reset()
            }
        }
    }

    var editorView: some View {
        VStack {
            Image(uiImage: editorViewModel.selectedImage.image)
                .resizable()
                .scaledToFit()
                .frame(height: UIScreen.main.bounds.height * 0.45)
                .overlay {
                    if let maskImage = editorViewModel.maskImage {
                        GeometryReader { geo in
                            Image(uiImage: maskImage)
                                .resizable()
                                .aspectRatio(contentMode: .fill) // Fill the available space
                                .frame(width: geo.size.width, height: geo.size.height) // Match the parent frame
                                .opacity(0.5) // Half opacity
                        }
                    } else {
                        ImageDrawingView(strokeSize: $editorViewModel.strokeSize, isKeyboardVisible: self.editorViewModel.keyboardResponder.isKeyboardVisible, canvasView: editorViewModel.canvasView)
                    }
                }
                .overlay(alignment: .bottomLeading) {
                    Button(action: {
                        editorViewModel.isAutoDetectionMode.toggle()
                        if editorViewModel.isAutoDetectionMode {
                            guard let cgImage = editorViewModel.selectedImage.image.cgImage else { return }
                            do {
                                let maskImage = try SubjectLifter.getSubjectMask(from: cgImage)
                                self.editorViewModel.maskImage = maskImage
                            } catch {
                                editorViewModel.isAutoDetectionMode.toggle()
                                editorViewModel.autodetectDidFail = true
                                print("No subjects detected")
                            }
                        } else {
                            editorViewModel.maskImage = nil
                        }
                    }) {
                        HStack {
                            Text("Auto-Mask")
                            Image(systemName: editorViewModel.autodetectDidFail ? "person.crop.circle.badge.questionmark" : "wand.and.stars")
                                .foregroundColor(editorViewModel.isAutoDetectionMode ? .accentColor : editorViewModel.autodetectDidFail ? .red : .white)
                                .shadow(color: .black, radius: 2)
                        }
                        .font(.footnote)
                        .foregroundColor(.white)
                        .padding(.vertical, 5)
                        .padding(.horizontal, 10)
                        .background(Color.black.opacity(0.5))
                        .clipShape(Capsule())
                    }
                    .padding()
                }
            
            VStack {
                HStack {
                    Text("Adjust stroke size")
                        .bold()
                        .padding([.leading])
                    Spacer()
                }
                Slider(value: $editorViewModel.strokeSize, in: 0.0...10.0) {
                    Text("Label")
                } minimumValueLabel: {
                    Image(systemName: "circle.fill")
                        .font(.system(size: 10))
                } maximumValueLabel: {
                    Image(systemName: "circle.fill")
                        .font(.system(size: 20))
                }
                .accentColor(Color(hex: "#7E76FA"))
                .padding([.leading, .trailing])
            }
            .padding([.top])
            
            VStack {
                HStack {
                    Text("Enter Prompt")
                        .bold()
                        .padding([.leading])
                    Spacer()
                }
                HStack {
                    TextField("A cute thing...", text: $editorViewModel.imagePrompt, axis: .vertical)
                        .padding([.leading])
                        .frame(minHeight: 60)
                        .modifier(KeyboardResponsiveModifier())
                        .background(Color(UIColor.systemGroupedBackground))
                        .shadow(color: .gray, radius: 1)
                        .modifier(ShakeEffect(animatableData: CGFloat(editorViewModel.attempts)))
                }
            }
            
            Button {
                if !self.editorViewModel.rateLimiter.canAddRequest() {
                    // no-op, as we are rate limited and should not generate an image
                } else if self.editorViewModel.imagePrompt == "" {
                    withAnimation {
                        // shake textfield for each invalid prompt
                        // currently the only invalid prompt is empty
                        editorViewModel.attempts += 1
                    }
                } else {
                    // otherwise, setting this will result in the loading view popping up
                    self.editorViewModel.isGeneratingImage = true
                    Task {
                        await fetchImageFromAPI()
                    }
                }
            } label: {
                if (self.editorViewModel.rateLimiter.canAddRequest()) {
                    HStack {
                        Image(systemName: "sparkles")
                        Text("Generate")
                    }
                    .padding()
                    .frame(maxWidth: .greatestFiniteMagnitude)
                    .foregroundColor(.white)
                    .background(Color(hex: "#7E76FA"))
                    .cornerRadius(10)
                } else {
                    HStack {
                        Image(systemName: "x.square")
                        Text("Try again in \(lround(self.editorViewModel.rateLimiter.timeUntilReset() / 60)) minutes")
                    }
                    .padding()
                    .frame(maxWidth: .greatestFiniteMagnitude)
                    .foregroundColor(.white)
                    .background(.gray)
                    .cornerRadius(10)
                }
            }
            .padding()
        }
    }

    // a loading screen displayed when waiting for results from the API
    var loadingView: some View {
        VStack {
            Spacer()
            LoadingCircleView()
            Spacer()
            #if DEBUG
            Button {
                self.editorViewModel.showDebugView.toggle()
            } label: {
                Text("[Debug]")
                    .font(.footnote)
                    .padding()
            }
            .sheet(isPresented: $editorViewModel.showDebugView) {
                EditorDebugView(selectedImage: self.editorViewModel.selectedImage)
            }
            #endif
        }
        .alert(isPresented: $editorViewModel.showAlert, content: {
            Alert(
                title: Text("Failed to generate image, please try again"),
                message: Text("\(self.editorViewModel.error?.failureReason ?? "Unknown Reason")"),
                dismissButton: .default(Text("Dismiss"), action: {
                    // if there is an error, exit the editor modal view when the user dismisses the alert
                    self.presentationMode.wrappedValue.dismiss()
                    self.editorViewModel.reset()
                })
            )
        })
    }

    func fetchImageFromAPI() async {
        // increment rate limiter with new task
        RateLimiter.shared.addRequest()

        // update the edited image struct with the prompt
        self.editorViewModel.selectedImage.updatePrompt(prompt: self.editorViewModel.imagePrompt)
        
        if let mask = self.editorViewModel.maskImage {
            // AI detected mask
            self.editorViewModel.selectedImage.updateMask(maskImage: mask)
        } else {
            // update the edited image struct with the mask
            var canvasImage: UIImage = DEFAULT_EMPTY_IMAGE
            // grab the mask, edit the background to be white
            // then, invert colors so that the drawn areas are white
            let imageWithWhiteBackground = UIImage.imageWithWhiteBackground(from: self.editorViewModel.canvasView)
            let invertedImage = imageWithWhiteBackground.invertColors()
            let scaledInvertedImage = invertedImage!.scalePreservingAspectRatio(targetSize: self.editorViewModel.selectedImage.image.size)
            
            canvasImage = scaledInvertedImage
            self.editorViewModel.selectedImage.updateMask(maskImage: canvasImage)
        }
        
        // grab results from the Diffusion API
        var image: UIImage
        do {
            image = try await DiffusionAPI().img2img(
                prompt: self.editorViewModel.imagePrompt,
                promptimage: self.editorViewModel.selectedImage.image,
                promptmask: self.editorViewModel.selectedImage.maskImage
            )
        } catch {
            if let error = error as? LocalizedError {
                self.editorViewModel.error = error
            }
            self.editorViewModel.showAlert = true
            return
        }
        
        // convert UIImage back to NSData (NSData is natively compatible with SwiftData)
        // we go from UIImage -> NSData instead of just NSData to verify that we actually have a valid image
        guard let imageData = image.jpegData(compressionQuality: 1.0) else {
            self.editorViewModel.isGeneratingImage = false
            return
        }
        
        // create and save the generated image to SwiftData
        let generativeImage = GenerativeImage(
            id: UUID(),
            prompt: self.editorViewModel.imagePrompt,
            imageData: imageData
        )
        DispatchQueue.main.async {
            PetFusionApp.sharedModelContainer.mainContext.insert(generativeImage)
        }
        
        // set flags necessary to bring up the result view
        self.editorViewModel.generatedImage = generativeImage
        self.editorViewModel.isGeneratingImage = false
    }
}

#Preview {
    EditorView(editorViewModel: EditorViewModel())
}
